% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get-index-sims.R
\name{get_index_sims}
\alias{get_index_sims}
\title{Calculate a population index via simulation from the joint precision matrix}
\usage{
get_index_sims(
  obj,
  level = 0.95,
  return_sims = FALSE,
  area = rep(1, nrow(obj)),
  est_function = stats::median,
  agg_function = function(x) sum(exp(x))
)
}
\arguments{
\item{obj}{\code{\link[=predict.sdmTMB]{predict.sdmTMB()}} output with \code{sims > 0}.}

\item{level}{The confidence level.}

\item{return_sims}{Logical. Return simulation draws? The default (\code{FALSE}) is
a quantile summary of those simulation draws.}

\item{area}{A vector of grid cell/polyon areas for each year-grid cell (row
of data) in \code{obj}. Adjust this if cells are not of unit area or not all
the same area (e.g., some cells are partially over land/water). Note that
the area vector is added as \code{log(area)} to the raw values in \code{obj}. In
other words, the function assumes a log link, which typically makes sense.}

\item{est_function}{Function to summarize the estimate (the expected value).
\code{mean()} would be an alternative to \code{median()}.}

\item{agg_function}{Function to aggregate samples within each time slice.
Assuming a log link, the \code{sum(exp(x) * area)} default makes sense.}
}
\description{
Calculate a population index via simulation from the joint precision matrix.
Compared to \code{\link[=get_index]{get_index()}}, this version can be dramatically faster
if bias correction was turned on in \code{\link[=get_index]{get_index()}} while being approximately
equivalent. \strong{This is an experimental function.} We have yet to find a model
where this function fails to provide a reasonable result, but make no
guarantees.
}
\details{
Can also be used to produce an index from a model fit with
\pkg{tmbstan}.

This function does nothing more than summarize and reshape the
matrix of simulation draws into a data frame.
}
\examples{
if (inla_installed()) {

m <- sdmTMB(density ~ 0 + as.factor(year) + depth_scaled + depth_scaled2,
  data = pcod_2011, spde = pcod_mesh_2011, family = tweedie(link = "log"),
  time = "year"
)
qcs_grid_2011 <- subset(qcs_grid, year >= 2011)
p <- predict(m, newdata = qcs_grid_2011, sims = 100)
x <- get_index_sims(p)
x_sims <- get_index_sims(p, return_sims = TRUE)

if (require("ggplot2", quietly = TRUE)) {
  ggplot(x, aes(year, est, ymin = lwr, ymax = upr)) +
    geom_line() +
    geom_ribbon(alpha = 0.4)
  ggplot(x_sims, aes(as.factor(year), .value)) +
    geom_violin()
}

}
}
\seealso{
\code{\link[=get_index]{get_index()}}
}
