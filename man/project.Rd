% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/project.R
\name{project}
\alias{project}
\title{Project from an \pkg{sdmTMB} model using simulation}
\usage{
project(
  object,
  newdata,
  nproj = 1,
  nsim = 1,
  silent = FALSE,
  sims_var = "eta_i",
  model = 1,
  return_tmb_report = FALSE,
  ...
)
}
\arguments{
\item{object}{A fitted model from \code{\link[=sdmTMB]{sdmTMB()}}.}

\item{newdata}{A new data frame to predict on. Should contain all new time
elements.}

\item{nproj}{Number of years to project.}

\item{nsim}{Number of simulations.}

\item{silent}{Silent?}

\item{sims_var}{Element to extract from the \pkg{TMB} report. Also see
\code{return_tmb_report}.}

\item{model}{Linear predictor number to extract. Also see
\code{return_tmb_report}.}

\item{return_tmb_report}{Return the \pkg{TMB} report from \code{simulate()}? This
lets you parse out whatever elements you want from the simulation including
grabbing multiple elements from one set of simulations. See examples.}

\item{...}{Passed to \code{\link[=predict.sdmTMB]{predict.sdmTMB()}}.}
}
\value{
If \code{return_tmb_report = FALSE} (default): a matrix with N rows equal to the
number of rows in \code{newdata} and N columns equal to \code{nsim}.

If \code{return_tmb_report = TRUE}: a list of TMB reports from \code{simulate()}. Run
\code{names()} on the output to see the options.

TODO: fill in more details.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

The function enables projecting forward in time from an
\pkg{sdmTMB} model using a simulation approach for computational efficiency.
This can be helpful for calculating predictive intervals for long
projections where including those time elements in \code{extra_time} during model
estimation can be slow.

Inspiration for this approach comes from the \pkg{VAST} function
\code{project_model()} by J.T. Thorson.
}
\examples{
\dontshow{if (ggplot2_installed()) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
library(ggplot2)

mesh <- make_mesh(dogfish, c("X", "Y"), cutoff = 25)
historical_years <- 2004:2022
to_project <- 10
future_years <- seq(max(historical_years) + 1, max(historical_years) + to_project)
all_years <- c(historical_years, future_years)
proj_grid <- replicate_df(wcvi_grid, "year", all_years)

# we could fit our model like this, but for long projections, this becomes slow:
fit <- sdmTMB(
  catch_weight ~ 1,
  time = "year",
  offset = log(dogfish$area_swept),
  extra_time = all_years, #< note that all years here
  spatial = "on",
  spatiotemporal = "ar1",
  data = dogfish,
  mesh = mesh,
  family = tweedie(link = "log")
)

# instead, we could fit our model like this and then take simulation draws
# from the projection time period:
fit2 <- sdmTMB(
  catch_weight ~ 1,
  time = "year",
  offset = log(dogfish$area_swept),
  extra_time = historical_years, #< does *not* include projection years
  spatial = "on",
  spatiotemporal = "ar1",
  data = dogfish,
  mesh = mesh,
  family = tweedie(link = "log")
)

# we will only use 20 `nsim` so this example runs quickly
# you will likely want many more (> 200) in practice so the result
# is relatively stable

set.seed(1)
out <- project(fit2, newdata = proj_grid, nproj = to_project, nsim = 20)
est_mean <- apply(out, 1, mean) # summarize however you'd like
est_se <- apply(out, 1, sd)

# visualize:
proj_grid$est_mean <- est_mean
ggplot(subset(proj_grid, year > 2021), aes(X, Y, fill = est_mean)) +
  geom_raster() +
  facet_wrap(~year) +
  coord_fixed() +
  scale_fill_viridis_c() +
  ggtitle("Projection simulation (mean)")

# if instead we wanted to grab, say, the spatiotemporal random field values,
# we can return the report and work with the raw output ourselves:

set.seed(1)
out <- project(
  fit2,
  newdata = proj_grid, nproj = to_project,
  nsim = 20, # increase this
  return_tmb_report = TRUE #< difference from above example
)

# here are the elements we could extract:
names(out[[1]])

# 'epsilon_st_A_vec' are the 'epsilon_st' at every location in 'newdata':
eps <- lapply(out, \(x) x[["epsilon_st_A_vec"]][, 1])
eps <- do.call(cbind, eps)
eps_mean <- apply(eps, 1, mean) # summarize however you'd like
eps_se <- apply(eps, 1, sd)

proj_grid$eps_mean <- eps_mean
ggplot(subset(proj_grid, year > 2021), aes(X, Y, fill = eps_mean)) +
  geom_raster() +
  facet_wrap(~year) +
  scale_fill_gradient2() +
  coord_fixed() +
  ggtitle("Projection simulation\n(spatiotemporal fields)")

proj_grid$eps_se <- eps_se
ggplot(subset(proj_grid, year > 2021), aes(X, Y, fill = eps_se)) +
  geom_raster() +
  facet_wrap(~year) +
  scale_fill_viridis_c() +
  coord_fixed() +
  ggtitle("Projection simulation\n(spatiotemporal fields standard error)")
\dontshow{\}) # examplesIf}
}
\references{
\code{project_model()} in the \pkg{VAST} package.
}
