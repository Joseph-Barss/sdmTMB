% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{sdmTMBcontrol}
\alias{sdmTMBcontrol}
\title{Optimization control options}
\usage{
sdmTMBcontrol(
  eval.max = 10000,
  iter.max = 10000,
  normalize = FALSE,
  nlminb_loops = 1,
  newton_loops = 0,
  mgcv = TRUE,
  quadratic_roots = FALSE,
  start = NULL,
  map_rf = FALSE,
  map = NULL,
  lower = NULL,
  upper = NULL,
  multiphase = TRUE,
  get_joint_precision = TRUE,
  ...
)
}
\arguments{
\item{eval.max}{Maximum number of evaluations of the objective function
allowed.}

\item{iter.max}{Maximum number of iterations allowed.}

\item{normalize}{Logical: use \code{\link[TMB:normalize]{TMB::normalize()}} to normalize the process
likelihood using the Laplace approximation? Can result in a substantial
speed boost in some cases. This used to default to \code{FALSE} prior to
May 2021.}

\item{nlminb_loops}{How many times to run \code{\link[stats:nlminb]{stats::nlminb()}} optimization.
Sometimes restarting the optimizer at the previous best values aids
convergence. If the maximum gradient is still too large,
try increasing this to \code{2}.}

\item{newton_loops}{How many Newton optimization steps to try with
\code{\link[stats:optim]{stats::optimHess()}} after running \code{\link[stats:nlminb]{stats::nlminb()}}. Sometimes aids
convergence.}

\item{mgcv}{Parse the formula with \code{\link[mgcv:gam]{mgcv::gam()}}?}

\item{quadratic_roots}{Experimental feature for internal use right now; may
be moved to a branch. Logical: should quadratic roots be calculated? Note:
on the sdmTMB side, the first two coefficients are used to generate the
quadratic parameters. This means that if you want to generate a quadratic
profile for depth, and depth and depth^2 are part of your formula, you need
to make sure these are listed first and that an intercept isn't included.
For example, \code{formula = cpue ~ 0 + depth + depth2 + as.factor(year)}.}

\item{start}{A named list specifying the starting values for parameters. You
can see the necessary structure by fitting the model once and inspecting
\code{your_model$tmb_obj$env$parList()}. Elements of \code{start} that are specified
will replace the default starting values.}

\item{map_rf}{Map all the random fields to 0 to turn the model into a
classical GLM or GLMM without spatial or spatiotemporal components?
Note this is not accounted for in \code{print()} or \code{tidy.sdmTMB()};
some parameters will still appear but their values can be ignored.}

\item{map}{A named list with factor \code{NA}s specifying parameter values that
should be fixed at a constant value. See the documentation in
\code{\link[TMB:MakeADFun]{TMB::MakeADFun()}}. This should usually be used with \code{start} to specify the
fixed value.}

\item{lower}{An optional named list of lower bounds within the optimization.
Parameter vectors with the same name (e.g., \code{b_j} or \code{ln_kappa} in some
cases) can be specified as a numeric vector. E.g.
\code{lower = list(b_j = c(-5, -5))}.}

\item{upper}{An optional named list of upper bounds within the optimization.}

\item{multiphase}{Logical: estimate the fixed and random effects in phases?
Phases are usually faster and more stable.}

\item{get_joint_precision}{Logical. Passed to \code{getJointPrecision} in
\code{\link[TMB:sdreport]{TMB::sdreport()}}. Must be \code{TRUE} to use simulation-based methods in
\code{\link[=predict.sdmTMB]{predict.sdmTMB()}} or \verb{[get_index_sims()]}. If not needed, setting this
\code{FALSE} will reduce object size.}

\item{...}{Anything else. See the 'Control parameters' section of
\code{\link[stats:nlminb]{stats::nlminb()}}.}
}
\description{
\code{\link[=sdmTMB]{sdmTMB()}} and \code{\link[stats:nlminb]{stats::nlminb()}} control options.
}
